stages:
  - build
  - deploy

workflow:
  rules:
    - when: always

variables:
  DOCKER_TLS_CERTDIR: ""
  DOCKER_BUILDKIT: 1
  BUILDKIT_PROGRESS: plain
  IMAGE_TAG: "latest"
  CACHE_DIR: ".buildx-cache"

  REGISTRY_URL: "docker.adesso.claims"
  REGISTRY_REPO: "docker.adesso.claims/regress"

  # Öffentlicher Port für sharepoint-ingest, falls direkt aus dem Browser genutzt
  INGEST_PORT: "8091"

ci_noop:
  stage: build
  image: alpine:3.19
  rules: [ { when: always } ]
  script: [ 'echo "No buildable changes detected. CI is alive ✅"' ]

.docker-build: &docker-build
  stage: build
  image: docker:24
  services: [ docker:24-dind ]
  before_script:
    # Login private Registry
    - echo "$REGISTRY_PASSWORD" | docker login "$REGISTRY_URL" -u "$REGISTRY_USER" --password-stdin
    # NEU: Login Docker Hub (erhöht Pull-Limits -> verhindert 429)
    - if [ -n "${DOCKERHUB_USERNAME:-}" ] && [ -n "${DOCKERHUB_TOKEN:-}" ]; then
      echo "$DOCKERHUB_TOKEN" | docker login docker.io -u "$DOCKERHUB_USERNAME" --password-stdin ;
      fi
    - apk add --no-cache bash coreutils
    - docker buildx create --use || docker buildx use default
    - mkdir -p "$CACHE_DIR"
  script:
    - bash -lc 'set -euo pipefail;
      docker buildx build --pull --push
      --build-arg BUILDKIT_INLINE_CACHE=1
      --cache-from=type=local,src="$CACHE_DIR"
      --cache-to=type=local,dest="$CACHE_DIR-new",mode=max
      -t "${REGISTRY_REPO}:${IMAGE_NAME}-${IMAGE_TAG}"
      -t "${REGISTRY_REPO}:${IMAGE_NAME}-${CI_COMMIT_SHORT_SHA}"
      -f "$DOCKERFILE" .'
    - bash -lc 'rm -rf "$CACHE_DIR" && mv "$CACHE_DIR-new" "$CACHE_DIR"'
  cache:
    key:
      files: [ Cargo.lock, frontend/package-lock.json ]
      prefix: "$CI_JOB_NAME"
    paths:
      - ~/.cargo/registry
      - ~/.cargo/git
      - ~/.cache/sccache
      - target
      - frontend/node_modules/.cache
      - .buildx-cache
  timeout: 90m
  needs: []

build_api_gateway:
  <<: *docker-build
  variables: { IMAGE_NAME: "api-gateway", DOCKERFILE: "services/api-gateway/Dockerfile" }
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ .gitlab-ci.yml, docker-compose.prod.yml ]
    - changes: [ Cargo.toml, Cargo.lock, shared/**/*, services/api-gateway/**/* ]

build_pdf_ingest:
  <<: *docker-build
  variables: { IMAGE_NAME: "pdf-ingest", DOCKERFILE: "services/pdf-ingest/Dockerfile" }
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ .gitlab-ci.yml, docker-compose.prod.yml ]
    - changes: [ Cargo.toml, Cargo.lock, shared/**/*, services/pdf-ingest/**/* ]

build_text_extraction:
  <<: *docker-build
  variables: { IMAGE_NAME: "text-extraction", DOCKERFILE: "services/text-extraction/Dockerfile" }
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ .gitlab-ci.yml, docker-compose.prod.yml ]
    - changes: [ Cargo.toml, Cargo.lock, shared/**/*, services/text-extraction/**/* ]

build_pipeline_runner:
  <<: *docker-build
  variables: { IMAGE_NAME: "pipeline-runner", DOCKERFILE: "services/pipeline-runner/Dockerfile" }
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ .gitlab-ci.yml, docker-compose.prod.yml ]
    - changes: [ Cargo.toml, Cargo.lock, shared/**/*, services/pipeline-runner/**/* ]

build_prompt_manager:
  <<: *docker-build
  variables: { IMAGE_NAME: "prompt-manager", DOCKERFILE: "services/prompt-manager/Dockerfile" }
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ .gitlab-ci.yml, docker-compose.prod.yml ]
    - changes: [ Cargo.toml, Cargo.lock, shared/**/*, services/prompt-manager/**/* ]

build_pipeline_api:
  <<: *docker-build
  variables: { IMAGE_NAME: "pipeline-api", DOCKERFILE: "services/pipeline-api/Dockerfile" }
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ .gitlab-ci.yml, docker-compose.prod.yml ]
    - changes: [ Cargo.toml, Cargo.lock, shared/**/*, services/pipeline-api/**/* ]

build_metrics:
  <<: *docker-build
  variables: { IMAGE_NAME: "metrics", DOCKERFILE: "services/metrics/Dockerfile" }
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ .gitlab-ci.yml, docker-compose.prod.yml ]
    - changes: [ Cargo.toml, Cargo.lock, shared/**/*, services/metrics/**/* ]

build_history_service:
  <<: *docker-build
  variables: { IMAGE_NAME: "history-service", DOCKERFILE: "services/history-service/Dockerfile" }
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ .gitlab-ci.yml, docker-compose.prod.yml ]
    - changes: [ Cargo.toml, Cargo.lock, shared/**/*, services/history-service/**/* ]

build_sharepoint_ingest:
  <<: *docker-build
  variables: { IMAGE_NAME: "sharepoint-ingest", DOCKERFILE: "services/sharepoint-ingest/Dockerfile" }
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ .gitlab-ci.yml, docker-compose.prod.yml ]
    - changes: [ Cargo.toml, Cargo.lock, shared/**/*, services/sharepoint-ingest/**/* ]

build_frontend:
  <<: *docker-build
  variables:
    IMAGE_NAME: "frontend"
    DOCKERFILE: "frontend/Dockerfile"
    PUBLIC_HOST: "${PUBLIC_HOST:-helium.adesso.claims}"
    SCHEME: "${SCHEME:-http}"     # oder https
    WS_SCHEME: "${WS_SCHEME:-ws}" # oder wss
  script:
    - bash -lc 'set -euo pipefail;
      PUBLIC_HOST="${PUBLIC_HOST:-helium.adesso.claims}";
      SCHEME="${SCHEME:-http}";
      WS_SCHEME="${WS_SCHEME:-ws}";
      # Wenn sharepoint-ingest direkt veröffentlicht wird, verwende $INGEST_PORT
      INGEST_URL="$SCHEME://$PUBLIC_HOST:${INGEST_PORT:-8091}";
      docker buildx build --pull --push
      --build-arg BUILDKIT_INLINE_CACHE=1
      --cache-from=type=local,src="$CACHE_DIR"
      --cache-to=type=local,dest="$CACHE_DIR-new",mode=max
      --build-arg PUBLIC_HOST="$PUBLIC_HOST"
      --build-arg VITE_INGEST_URL="$INGEST_URL"
      --build-arg VITE_HISTORY_URL="$SCHEME://$PUBLIC_HOST:8090"
      --build-arg VITE_HISTORY_WS="$WS_SCHEME://$PUBLIC_HOST:8090"
      --build-arg VITE_API_URL="$SCHEME://$PUBLIC_HOST:8084"
      --build-arg VITE_UPLOAD_API_URL="$SCHEME://$PUBLIC_HOST:8081"
      -t "${REGISTRY_REPO}:${IMAGE_NAME}-${IMAGE_TAG}"
      -t "${REGISTRY_REPO}:${IMAGE_NAME}-${CI_COMMIT_SHORT_SHA}"
      -f "$DOCKERFILE" .'
    - bash -lc 'rm -rf "$CACHE_DIR" && mv "$CACHE_DIR-new" "$CACHE_DIR"'
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ .gitlab-ci.yml, docker-compose.prod.yml ]
    - changes: [ frontend/**/* ]

build_migrations_image:
  stage: build
  image: docker:24
  services: [ docker:24-dind ]
  variables:
    IMAGE_NAME: "migrations"
    DOCKERFILE: "migrations/Dockerfile"
  before_script:
    - echo "$REGISTRY_PASSWORD" | docker login "$REGISTRY_URL" -u "$REGISTRY_USER" --password-stdin
    # NEU: Docker Hub Login auch hier (Basisimage postgres)
    - if [ -n "${DOCKERHUB_USERNAME:-}" ] && [ -n "${DOCKERHUB_TOKEN:-}" ]; then
      echo "$DOCKERHUB_TOKEN" | docker login docker.io -u "$DOCKERHUB_USERNAME" --password-stdin ;
      fi
    - docker buildx create --use || docker buildx use default
    - mkdir -p "$CACHE_DIR"
  script:
    - |
      set -euo pipefail
      test -d migrations || { echo "ERROR: migrations/ fehlt im Checkout"; ls -la; exit 1; }
      docker buildx build --pull --push \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --cache-from=type=local,src="$CACHE_DIR" \
        --cache-to=type=local,dest="$CACHE_DIR-new",mode=max \
        -f "$DOCKERFILE" \
        -t "${REGISTRY_REPO}:${IMAGE_NAME}-latest" \
        -t "${REGISTRY_REPO}:${IMAGE_NAME}-${CI_COMMIT_SHORT_SHA}" \
        .
      rm -rf "$CACHE_DIR" && mv "$CACHE_DIR-new" "$CACHE_DIR"
  rules:
    - if: '$FORCE_BUILD_ALL == "1"'
    - changes: [ migrations/**, .gitlab-ci.yml ]
  timeout: 30m
  needs: []

deploy_manual_info:
  stage: deploy
  image: alpine:3.19
  rules: [ { when: manual, allow_failure: false } ]
  script: |
    set -e
    SERVICES="api-gateway pdf-ingest text-extraction pipeline-runner prompt-manager pipeline-api metrics history-service frontend sharepoint-ingest"
    echo "Registry repo: $REGISTRY_REPO"
    echo
    echo "Pull diese Tags in Portainer (Images → Pull):"
    for s in $SERVICES; do
      echo "  $REGISTRY_REPO:${s}-${IMAGE_TAG}"
      echo "  $REGISTRY_REPO:${s}-${CI_COMMIT_SHORT_SHA}"
    done
    echo
    echo "Beispiel docker-compose.yml (Release-Tags):"
    echo "services:"
    for s in $SERVICES; do
      echo "  $s:"
      echo "    image: $REGISTRY_REPO:${s}-${IMAGE_TAG}"
    done
  artifacts:
    when: always
    expire_in: 3 days
    paths: [ deploy-instructions.txt ]
